## Malware-Checker

This is an API written in Python. APi has been built based on the Flask framework.

**Get Request Format:**

```
GET /urlinfo/1/{hostname_and_port}/{original_path_and_query_string}
```

**Response Codes:**

The server generates the following HTTP response codes for the GET request:

```
200: The queried URL is either phishing, malware, or both. Specific type will also be present in the response body
204: Either - the requested url is safe to browse or the requested url isn't present in the malware database. Both points to safe url. There won't be any specific type mentkioned in the response since it's not reported as malicious  
400: Bad Requestâ€”The HTTP request was not correctly formed.
404: Not Found - Invalid Request
```
**Workflow**

Have considered urls of following syntax:

1. google.com
2. www.google.com
3. www.google.com:<port>
4. www.google.com/v1sdsd/dsdsd?id=kkk&sdsds&sdsd
5. Normal text

**Url Exclusions**

Currently, I havent added the part to handle schema - http and https part. So, please exclude that part from the urls to be tested.

**Screenshots**

![Malicious Url](https://github.com/sreenathmmenon/malware-checker/blob/master/screenshots/postman_results_malware_url.png)


**Response Syntax**

**Ex - http://localhost:5000/urlinfo/1/giants.yourzip.co/static/quotes.js?ver=d58072be2820e8682c0a27c0518e805e**
(Sample url taken from - http://www.malwaredomainlist.com/mdl.php)

```
{
    "domain": "giants.yourzip.co",
    "is_malicious": "true",
    "message": "Harmful Url. Not recommended to visit",
    "port": null,
    "status": 200,
    "url_type": "phishing"
}
```


![Safe Url](https://github.com/sreenathmmenon/malware-checker/blob/master/screenshots/postman_safe_url.png)


**Ex - http://localhost:5000/urlinfo/1/google.com:8080/**

```
{
    "domain": "google.com",
    "is_malicious": "false",
    "message": "Url is safe to browse.",
    "port": 8080,
    "status": 204
}
```

![Url not present in malicious database](https://github.com/sreenathmmenon/malware-checker/blob/master/screenshots/postman_data_not_present_db.png)

**Ex - http://localhost:5000/urlinfo/1/google.com:5000**

```
{
    "domain": "google.com",
    "message": "Data not present in our database",
    "port": "5000",
    "status": 204
}
```


![Full Url display](https://github.com/sreenathmmenon/malware-checker/blob/master/screenshots/postmna_full_url_list.png)


**Ex - http://localhost:5000/urlinfo/1/**

```
[
    {
        "category": "malware",
        "created_on": "2018-05-27T14:27:35+00:00",
        "domain": "google.com",
        "id": 1,
        "is_malicious": "true",
        "port": 80,
        "query_string": null,
        "updated_on": null
    },
    {
        "category": "malware",
        "created_on": "2018-05-27T15:27:35+00:00",
        "domain": "google.com",
        "id": 2,
        "is_malicious": "false",
        "port": 8080,
        "query_string": null,
        "updated_on": null
    },
    {
        "category": "malware",
        "created_on": "2018-05-27T15:28:35+00:00",
        "domain": "google.com",
        "id": 3,
        "is_malicious": "true",
        "port": 9080,
        "query_string": null,
        "updated_on": null
    },
    {
        "category": "phishing",
        "created_on": "2018-02-10T10:20:56+00:00",
        "domain": "textspeier.de",
        "id": 4,
        "is_malicious": "true",
        "port": null,
        "query_string": null,
        "updated_on": null
    },
    {
        "category": "phishing",
        "created_on": "2018-02-10T10:20:56+00:00",
        "domain": "giants.yourzip.co",
        "id": 5,
        "is_malicious": "true",
        "port": null,
        "query_string": "static/quotes.js?ver=d58072be2820e8682c0a27c0518e805e",
        "updated_on": null
    }
]
```

## API Framework

**Pecan v/s Flask  and I chose Flask**

My Plan was to use Pecan framework as I had some experience in that. But later, I have moved onto Flask.
One majore advanatge of Flask is the freedom that it gives developers to organizze the api structure in whatever way they want.
Another major advantage which I experienced was the large community support of Flask. Whenever I search for any options or solutions related to Flask, I get several different solutions and articles relayetd to that. But the support for pecan is still small.

Also, found out that Flask is used by large compnies like Pinterest and Twilio and the customers are getting several thousands of requests in each hour.

**ORM**

My experiemce in ORM was limited to SQLAlchemy. The main option whcih I had here was to write sql conenction directly fetch data via raw queries or to use an ORM.
For the initial stage of api, using raw queries was sufficient. However, the api will surely get bigger without new functionality.
Hence, I chose and ORM and preferred to use SQLAlchemy as it's a proven one.

**API Structuring**

In the case of Pecan, there was a well defined structure for the API with a boilerplate sturcture getting generated on creating an app.
In the case of Flask, everything is utp the developers. So, a developer himself can group the sections adn create a good api structure.

## Scaling Solutions

**Database**

My plan was to chose MySQL initially and then move onto PostgresSQL as PostgresSQL has great advantages in terms of Concurrency and read locks.
Even if we are using MySQL, the our api will work. MySQL can also handle large data. However, usage of PostgresSQL has more advanatges than MySQL.


An important thing is Scaling corresponding to large data or large number of requests is that - it's not related to Modifications in Flask or Python Code.
Usually for an app we handle scaling interms of the following:

1. Servers 
2. Databases,
3. Caching solutions
4. Using Message Queues like RabbitMQ, etc
5. Using Load Balancing  -Nginx, HAproxy and Varnish for static-delivery and load-balancing.

**Suggested solution with 2 nodes for api and 2 nodes for db + Haproxy servers**

- We have 2 db nodes - database1 and database2.
- We also have 2 nodes where we will run the api - backend1, backend2.
- We have HAproxy load balancer setup. We are also using RabbitMQ messaging service which handles queue management for various services and their communications.
- In the conig file of pur current API as well any other service- we can pass the ip of HA Proxy which is the load balancer for db connection.
- In the haproxy config file, we can specify the backend_server/nodes, which are to be pointed corresponding to this mysql_backend.
- If 10.0.10.20 nad 10.0.10.21 are the ip's corresponding to database1 and database2 nodes, then we will be passing these ip's in the haproxy and configuring the load balancing.
- Similarly, we will take the Ip's of backend1 and backend2 where our api is running and pass it in the haproxy config file for setting load balancing for the APi service.


Then the workflow will be like this:

1. Each time we load the api url, the request will be going to different nodes.
2. Even if one node is down, other node can handle the requests without and problem.
3. Similary, for database read & write, we are having mutliple database nodes plus loadbalancer setup. So, they can handle requests without any issues.

(Note- Node/Instance Count can be increased based on the requirements)


**Sample Query to add data to DB**

```
INSERT INTO `malware_data` VALUES (1,'google.com',80,NULL,'malware','true','2018-05-27 14:27:35',NULL),(2,'google.com',8080,NULL,'malware','false','2018-05-27 15:27:35',NULL),(3,'google.com',9080,NULL,'malware','true','2018-05-27 15:28:35',NULL),(4,'textspeier.de',NULL,NULL,'phishing','true','2018-02-10 10:20:56',NULL),(5,'giants.yourzip.co',NULL,'static/quotes.js?ver=d58072be2820e8682c0a27c0518e805e','phishing','true','2018-02-10 10:20:56',NULL);
```


